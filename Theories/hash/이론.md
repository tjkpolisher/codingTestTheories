# 해시 개념
어떠한 값이 저장되는 위치를 어떤 규칙으로 정할 수 있다면 굳이 탐색을 할 필요 없이 바로 데이터를 찾아낼 수 있을 겁니다. 해시(Hash)는 이러한 생각을 바탕으로 만들어진 자료구조입니다. 해시는 **해시 함수를 사용해서 변환한 값을 인덱스로 삼아 키와 값을 저장해서 빠른 데이터 탐색을 제공하는 자료구조**입니다. 어떻게 탐색을 빠르게 만들까요? 보통은 인덱스를 활용해서 탐색을 빠르게 만들지만 해시는 키(key)를 활용해 데이터 탐색을 빠르게 합니다.  
> 해시는 키와 데이터를 일대일 대응하여 저장하므로 키를 통해 데이터에 바로 접근할 수 있습니다. 사람에게는 숫자(인덱스)로 데이터를 관리하는 배열보다 조금 더 접근성이 좋은 자료구조입니다.  

## 해시 자세히 알아보기
실생활에서 가장 쉽게 볼 수 있는 해시의 예는 연락처입니다. 내가 얻고자 하는 정보, 즉 전화번호는 **값**(value)이고, 값을 검색하기 위해 활용하는 정보는 **키**(key)입니다. 그리고 그 사이에 키를 이용해 해시값 또는 인덱스로 변환하는 해시 함수가 있습니다. 해시 함수는 이렇게 일정한 키를 일정한 해시값으로 변환시켜 값을 찾을 수 있게 해줍니다. 해시 함수에 대한 건 아래에서 다시 자세하게 설명하고, 여기서는 이런 식으로 동작한다는 컨셉과 동작만 알아보겠습니다.

## 해시의 특징
1. 해시는 단방향으로 작동합니다.<br/>키를 통해 값을 찾을 수는 있지만, 반대로 값을 통해 키를 찾을 수는 없습니다. 이러한 특징 때문에 외부에 정보를 안전하게 제공한다는 특징이 있어 네트워크 보안에서 많이 활용됩니다.
2. 찾고자 하는 값을 $O\left(1\right)$에서 바로 찾을 수 있습니다.<br/>키 자체가 해시 함수에 의해 값이 있는 인덱스가 되므로, 값을 찾기 위한 탐색 과정이 필요 없습니다.
3. 값을 인덱스로 활용하려면 적절한 변환 과정을 거쳐야 합니다.  
### 해시를 사용하지 않으면 어떻게 될까?
해시를 사용하지 않는다면 우리는 값의 위치에 대한 어떤 정보도 알 수 없을 겁니다. 그래서 어떤 데이터를 찾으려면 전체 데이터를 확인해보는 방법 밖에는 없을 겁니다.  
반면 해시를 사용하면 순차 탐색할 필요가 없이 해시 함수를 활용해서 특정 값이 있는 위치를 바로 찾을 수 있어 탐색 효율이 좋습니다. 여기서 키와 대응한 값이 저장된 공간을 **해시 테이블**(hash table)이라 하며, 해시 테이블의 각 데이터를 **버킷**(bucket)이라고 부릅니다.  

## 해시의 특성을 활용하는 분야
해시는 단방향으로만 검색할 수 있는 대신 빠르게 원하는 값을 검색할 수 있습니다. 이런 해시의 특성은 데이터를 저장하고 검색하거나, 보안이 필요할 때 활용됩니다. 코딩 테스트에서는 특정 데이터를 탐색하는 횟수가 많을 경우 해시를 고려하면 좋습니다. 아래는 해시가 활용되는 실제 사례입니다.  
* 비밀번호 관리: 사용자의 비밀번호를 그대로 노출해 저장하는 것은 위험하므로 해시 함수를 활용해 해싱한 비밀번호를 저장합니다. 비밀번호가 맞는지 확인할 때도 마찬가지입니다. 사용자가 입력한 비밀번호를 해싱해 확인합니다.
* 데이터베이스 인덱싱: DB에 저장된 데이터를 효율적으로 검색할 때 해시를 활용합니다.
* 블록체인: 해시 함수가 핵심적인 분야입니다. 각 블록은 이전 블록의 해시값을 포함하고 있으며, 이를 통해 데이터 무결성을 확인할 수 있습니다.

# 해시 함수
해시 함수를 구현하는 방법을 알기 전에, 이를 구현할 때 고려해야 하는 점을 알아야 합니다. 사실 코딩 테스트에서 해시 함수를 직접 구현하라는 문제가 나오는 경우는 거의 없습니다. **그리고 파이썬의 딕셔너리 자료형은 해시와 거의 동일하게 작동하므로 해시를 쉽게 사용할 수 있습니다.** 하지만 해시의 원리를 이해하고 딕셔너리를 사용하면 좀 더 효율적으로 딕셔너리를 사용할 수 있으므로 한 번쯤은 해시 개념을 공부하기를 추천합니다.  
## 해시 함수를 구현할 때 고려할 내용
1. 해시 함수가 변환한 값은 인덱스로 활용해야 하므로 해시 테이블의 크기를 넘으면 안 됩니다. 
2. 해시 함수가 변환한 값의 충돌은 최대한 적게 발생해야 합니다. 여기서 충돌이란 **서로 다른 두 키에 대해 해싱 함수를 적용한 결과가 동일한 것**을 뜻합니다. 충돌이 아예 발생하지 않는 해시 함수는 거의 없기 때문에, 그 횟수라도 최소화하는 것이 중요합니다.

## 자주 사용하는 해시 함수
### 나눗셈법
Division method. 가장 떠올리기 쉬운 단순한 해시 함수입니다. 키를 소수(prime number)로 나눈 나머지를 활용합니다. 이처럼 나머지를 취하는 연산을 모듈러 연산이라고 하며 연산자는 `%`로 표시합니다. 앞으로 나머지를 취하는 연산을 모듈러 연산이라고 하겠습니다. 수식으로 작성하면 아래와 같습니다.  
$$h\left(x\right)=x\mod m$$  
$x$는 키, $k$는 소수입니다. 키를 소수로 나눈 나머지를 인덱스로 사용하는 겁니다. 그림으로 나타내면 아래와 같습니다.  
![나눗셈법](hash_divisionMethod.png)  
### 나눗셈법에 소수가 아닌 수를 적용할 경우
소수를 사용하는 이유는 다른 수를 사용할 때보다 충돌이 적기 때문입니다. 예를 들어 소수가 아닌 15를 나눗셈법에 적용했다고 해보죠. 즉, $k=15$인 경우입니다. $x$가 3의 배수일 경우, 다음 그림을 보면 규칙적으로 계속 같은 해시값이 반복되는 것을 알 수 있습니다.  
![소수가 아닌 K](hash_notAPrimeNumber.png)  
해시값을 보면 동일한 값들이 계속 반복되며, 이를 해시값이 충돌되었다고 표현합니다. 왜 그럴까요? $x$가 $k$의 약수 중 하나인 3의 배수이기 때문입니다. $x$를 5의 배수로 생각해도 충돌이 많이 발생합니다.  
### 왜 충돌이 많이 발생할까?
이유는 간단합니다. $N$의 약수 중 하나를 $M$이라 하면, 임의의 수 $K$에 대해 $M\times K=N$이 되는 수가 반드시 존재합니다. 위 그림에서는 $N=15,\ M=3$인 경우입니다. $3\times 5=15$이므로 $K=5$가 됩니다. 그리고 그림은 $K$를 주기로 같은 해시값이 반복됨을 알 수 있습니다. 따라서 $K$는 1과 자신을 제외하면 약수가 없는 수인 소수를 사용하는 것이 좋습니다.  
### 나눗셈법의 해시 테이블 크기는 $K$
또한 나눗셈법에서 해시 테이블의 크기는 자연스럽게 $K$가 됩니다. 왜냐하면 $K$에 대해 모듈러 연산을 했을 때 나올 수 있는 값은 0 ~ K-1 이기 때문입니다. 즉, 상황에 따라 아주 많은 데이터를 저장해야 한다면 굉장히 큰 소수가 필요할 수도 있습니다. 아쉽게도 매우 큰 소수를 구하는 효율적인 방법은 아직 없으며, 필요한 경우 기계적인 방법으로 구해야 합니다. 이것이 나눗셈법의 단점 중 하나입니다.  

## 곱셈법