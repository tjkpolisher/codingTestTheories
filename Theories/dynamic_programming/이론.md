# 동적 계획법
사실 동적 계획법(dynamic programming, DP)은 특정한 알고리즘을 가리킨다기 보다는, 문제를 푸는 방법론 내지는 패러다임에 가깝습니다. 동적 계획법의 정의는 **전체 문제를 한 번에 해결하지 않고 작은 부분 문제로 쪼개서 해결한 뒤, 이를 활용해 전체 문제를 해결하는 방식**입니다. 그래서 혹자는 *동적이지도 않고*, *프로그래밍*(영문 명칭 기준)도 아니라고 하죠. 실제로 이걸 고안한 리처드 E. 벨만(Richard E. Bellman)은 그냥 멋있어서... 'dynamic'이라는 단어를 선택했다고 합니다.  
기본적으로 동적 계획법의 접근 방식은 분할 정복 알고리즘과 비슷합니다. 하지만, 동적 계획법의 활용에는 두 가지 전제조건이 필요합니다.
* 큰 문제를 작은 문제로 나누었을 때, 동일한 작은 문제가 반복해서 등장해야 한다.
* 큰 문제의 해결책은 작은 문제의 해결책의 합으로 구성되어야 한다.

핵심은 작은 문제들이 **같아야 하고, 반복되어야 한다**는 것입니다. 
## 점화식과 동적 계획법
수학에서 점화식(recurrence relation)은 수열에서 인접한 항들 사이의 관계식을 말합니다. 예를 들어 이전 두 항의 합을 현재의 항으로 설정하는 **피보나치 수열**은 아래와 같은 점화식으로 표현됩니다.  
$$a_{n+2} = a_{n+1}+a_n,\ a_1 = 1,\ a_2=1$$  
동적 계획법은 이러한 점화식과 밀접한 관계가 있습니다. 자세한 절차는 아래와 같습니다.
1. 문제를 해결하는 해가 이미 있다고 가정한다.
2. 종료 조건을 설정한다.
3. 1번과 2번 과정을 활용해 점화식을 세운다.

### 점화식 구현: 재귀 활용
이렇게 만들어진 점화식을 프로그래밍으로 표현할 때는 재귀 함수를 사용하면 간단합니다. 위의 피보나치 수열을 재귀 함수로 나타내면 아래와 같습니다.  

```Python
def fibo(x):
    if x == 1 or x == 2:  # 제1항 또는 제2항의 값은 1로 고정됨
        return 1
    return fibo(x - 1) + fibo(x - 2)
```  

그런데 피보나치 수열의 소스코드를 이렇게 작성하면 심각한 문제가 생길 수 있습니다. `x`가 커지면 커질수록 수행 시간이 기하급수적으로 늘어난다는 점이죠. 일반적으로 빅오 표기법을 이용하면 이 함수의 시간 복잡도는 $O\left(2^N\right)$입니다. $N=30$만 되더라도 $2^{30}$이니 약 10억 회 가량의 연산을 수행해야 하는 겁니다.  
더군다나 호출한 함수가 많으면 많을수록 스택 메모리에 함수 호출 정보가 쌓이기 때문에 입력값이 크다면 정답을 맞을 지언정 메모리 상한을 초과해 런타임 오류가 발생할 수도 있습니다.  
따라서 재귀 호출을 해서 문제가 생길 것 같다면 다른 방법들을 사용해야 합니다.  
1. 재귀 호출 자체를 쓰지 않는 반복문
2. 재귀 호출 횟수를 줄이는 메모이제이션

## 메모이제이션
Memoization. 이미 계산한 값을 저장해뒀다가 나중에 쓸 일이 있을 때 저장해둔 값을 그대로 가져오는 기법입니다. 값을 저장하는 방법이므로 캐싱(caching)이라고도 부릅니다.  
방법은 단순합니다. 한 번 구한 정보를 리스트에 저장하는 겁니다. 동적 계획법을 재귀적으로 수행하다가 같은 정보가 필요할 때는 이미 구한 정답을 리스트에서 꺼내오기만 하면 됩니다. 이를 피보나치 수열 코드에 적용하면 아래와 같습니다.  
```Python
# 한 번 계산한 결과를 메모이제이션하기 위한 리스트
d = [0] * 100 # 제99항을 구하기 위해 길이 100의 리스트를 생성

def fibo(x):
    if x == 1 or x == 2:
        return 1
    if d[x] != 0:
        return d[x]
    d[x] = fibo(x - 1) + fibo(x - 2)
    return d[x]

print(fibo(99))
```  

## 반복문 사용 시
재귀 함수를 이용하여 동적 계획법 소스 코드를 작성하는 방식을 탑다운(Top-down) 방식, 또는 하향식이라고 합니다. 큰 문제를 해결하기 위해 작은 문제를 호출한다고 해서 붙은 이름이죠. 반대로 단순히 반복문을 사용해 소스코드를 작성한다면 작은 문제부터 차근차근 답을 도출한다는 의미에서 바텀업(Bottom-up) 방식, 또는 상향식이라고 합니다. 반복문을 이용해 피보나치 함수를 구현하면 아래와 같습니다.  
```Python
d = [0] * 100

d[1] = 1
d[2] = 1
n = 99

for i in range(3, n + 1):
    d[i] = d[i - 1] + d[i - 2]

print(d[n])
```  
바텀업 방식에서 사용되는 결과 저장용 리스트는 특별히 **DP 테이블**이라고 부릅니다. 메모이제이션은 탑다운 방식에서만 사용되는 표현입니다. 엄밀히 말하면 메모이제이션과 동적 계획법은 서로 다른 개념이지만 두 개념을 혼용해서 사용하는 경우도 있습니다. 엄연히 다른 개념이라는 사실을 꼭 알아둡시다.

## 예제: 최장 증가 부분 수열
동적 계획법을 응용하기 좋은 몇몇 문제들을 더 살펴보죠. 그 중 하나인 **최장 증가 부분 수열**을 이해하려면 우선 *부분 수열*이 무엇인지부터 알아야 합니다.
### 부분 수열
Subsequence. 주어진 수열 중 일부를 뽑아서 새로 만든 수열을 말합니다. 이때 각각의 원소는 전후 관계를 유지해야 합니다. 예를 들어, 수열 $\left[1,4,2,3,1,5,7,3\right]$에서 2, 3, 1, 7을 뽑으면 부분 수열이 됩니다. 원소를 뽑을 때 5를 건너 뛰었지만 1과 7의 순서는 바뀌지 않았습니다.
### 최장 증가 부분 수열
Long increasing subsequence, LIS. 부분 수열의 원소가 오름차순을 유지하면서도 길이가 가장 긴 수열을 말합니다. 이때 이 수열은 같은 값이 존재해서는 안 되고 반드시 단조 증가만 하는 수열입니다. 앞서 본 수열의 경우 1, 2, 3, 5, 7을 뽑으면 최장 증가 부분 수열(LIS)이 됩니다.
### LIS의 길이를 동적 계획법으로 구하기
LIS를 처음 공부한다면 이 문제가 어려울 수 있습니다. 왜냐하면 수열의 숫자 크기와 위치를 동시에 고려해야 하기 때문이죠. 이 문제의 포인트는 LIS의 특징을 활용하는 것입니다.
* 숫자가 점점 증가한다.
* 원소 간의 전후 관계를 유지한다.

동적 계획법을 활용하기 위해 문제를 작게 쪼개보죠. 전체 수열의 LIS 길이를 구하는 문제는 **각 숫자로 끝나는 LIS의 길이 중 최대값을 구하는 문제로 바꿀 수 있습니다**(최적 부분 구조). 그리고 각 숫자로 끝나는 LIS를 구할 때 이전의 LIS 길이를 참조합니다(중복 부분 문제). 따라서 특정 숫자로 끝나는 LIS의 길이를 안다면 LIS의 길이를 구할 수 있습니다.  
여기서 특정 숫자로 끝나는 LIS의 길이는 앞에서 찾은 특정 원소로 끝나는 LIS 길이 중 가장 큰 것에 1을 더하면 됩니다. 단, LIS의 정의 때문에 앞의 원소가 자기 자신보다 작아야만 합니다. 그렇다는 말은 점화식을 세울 수 있다는 말이죠.  
여기서는 메모이제이션을 위한 `dp` 배열에 각 원소로 끝나는 LIS의 길이를 저장하고 마지막에 배열에 있는 값 중 가장 큰 값을 최종 LIS의 길이로 생각합니다. 즉, `dp[N]`은 `arr[N]`을 마지막 원소로 하는 LIS의 길이입니다. `dp`로 점화식을 세우면 다음과 같습니다.  
* $dp\left[N\right]=\max\left(dp\left[K\right]\right) + 1$ (단, $1 \le K < N, arr[K] < arr[N]$)
* $dp[1] = 1$ (종료 조건)  

```Python
def lis(nums):
    n = len(nums)

    dp = [1] * n

    for i in range(1, n):
        for j in range(i):
            if nums[i] > nums[j]:
                dp[i] = max(dp[i], dp[j] + 1)
    
    return max(dp)
```  
참고로 이 소스코드의 시간 복잡도는 이중 반복문으로 인해 $O\left(N^2\right)$입니다.  

## 예제: 최장 공통 부분 수열
Longest common subsequence, LCS. 엄밀한 의미의 수학과 달리 컴퓨터과학에서의 수열은 특정 순서로 나열한 객체를 의미합니다. 따라서 LCS는 두 수열이 어떤 기준에 따라 양쪽에서 공통으로 발견할 수 있는 가장 긴 부분 수열을 의미합니다. LIS와 마찬가지로 LCS도 부분 수열이기 때문에 원소 사이의 원래 순서만 유지하면 되고 반드시 연속할 필요는 없습니다.
### LCS의 길이를 동적 계획법으로 구하기
LCS의 길이를 찾는 문제는 입력값을 작게 하여 반복하여 풀 수 있는 작은 문제가 나오는지에 집중합니다. 이때 2가지 조건을 검사해야 합니다.
* 두 문자열의 특정 문자가 같은 지 여부
* 같다면 찾은 두 문자의 위치가 이전에 찾은 문자의 다음에 있는지 여부

일단 LCS의 길이를 구하는 함수를 다음과 같이 정의합니다.  
* LCS(i, j) = x[1$\cdots$i]와 y[1$\cdots$j]의 LCS의 길이

이때, 두 값 `x[i]`와 `y[j]`가 같지 않은 경우가 중요합니다. 두 값이 같다면 식이 성립하지만, 다르다면 마지막 문자를 빼고 가장 많은 문자열을 포함하는 LCS의 길이를 선택해야 합니다. 이런 과정을 일반화하면 아래와 같습니다.
* `x[i]`와 `y[j]`가 다르다면 LCS(i, j) = max(LCS(i - 1, j), LCS(i, j - 1))  

종합하자면, LCS(i, j)의 점화식은 아래와 같습니다.  
* $LCS\left(0,0\right) = 0$
* `x[i] == y[j]`이면 $LCS(i - 1, j - 1) + 1$
* `x[i] != y[j]`이면 $\max\left(LCS(i - 1, j), LCS(i, j - 1) \right)$  

```Python
def solution(str1, str2):
    m, n = len(str1), len(str2)

    dp = [[0] * (n + 1) for _ in range(m + 1)]

    for i in range(1, m + 1):
        for j in range(1, n + 1):
            if str1[i - 1] == str2[j - 1]:
                dp[i][j] = dp[i - 1][j - 1] + 1
            else:
                dp[i][j] = max(dp[i - 1][j], dp[i][j - 1])
    return dp[m][n]
```  
시간 복잡도는 $O\left(N\times M\right)$입니다.  

## 동적 계획법 관련 팁
코딩 테스트에서 동적 계획법은 대체로 간단한 형태로 출제됩니다. 문제를 푸는 첫 번째 단계는 주어진 문제가 동적 계획법 유형임을 평가하는 것입니다. 특정 문제를 완전 탐색 알고리즘으로 접근했을 때 지나치게 시간이 오래 걸린다면 동적 계획법을 적용할 수 있는지, 특히 해결하고자 한느 부분 문제들의 중복 여부를 확인합니다.  
일단 단순히 재귀 함수 비효율적인 프로그램을 탑다운으로 작성하되, 작은 문제에서 구한 답을 큰 문제에서 그대로 사용 가능하면 메모이제이션 기법을 추가로 활용하세요.  
또한 가능하다면 재귀 함수 대신 바텀업 방식의 반복문 형태를 구현하는 것을 권장합니다.  시스템상 재귀 함수의 제한을 `sys` 라이브러리에 포함된 `setrecursionlimit()` 함수로 완화할 수는 있다는 점도 알아두면 좋습니다.
