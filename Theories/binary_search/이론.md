# 탐색
## 들어가기에 앞서 - 순차 탐색
순차 탐색(Sequential serach)이란 **리스트 안에 있는 특정한 데이터를 찾기 위해 앞에서부터 데이터를 하나씩 차례대로 확인하는 방법**입니다. 이름에서 알 수 있듯이 순서대로 데이터를 탐색한다는 의미로, 보통 정렬되지 않은 리스트에서 데이터를 찾아야 할 때 사용합니다. 시간만 충분하다면 항상 원하는 데이터를 찾을 수 있다는 장점이 있습니다. ~~코테에서는 그럴 시간이 없다는 게 문제~~  
순차 탐색은 데이터의 정렬 여부와 상관없이 가장 앞에 있는 원소부터 하나씩 확인해야 하기 떄문에, 데이터가 $N$개일 때 최대 $N$번의 비교 연산을 해야 합니다. 따라서 최악의 경우 시간 복잡도는 $O\left(N\right)$입니다.  
파이썬에서 리스트 등의 안에 있는 원하는 데이터를 찾을 때 사용하는 `count()` 함수도 내부적으로 순차 탐색을 수행합니다.  
## 이진 탐색
탐색 속도를 높이는 대표적인 알고리즘으로 이진 탐색(binary search)가 있습니다. 이진 탐색은 배열 내부의 데이터가 정렬되어 있어야 사용할 수 있습니다. 하지만 이미 정렬되어 있다는 전제 하에 매우 빠르게 데이터를 찾을 수 있습니다. 이것이 가능한 이유는 탐색 범위를 절반씩 줄여가며 데이터를 탐색하는 특성 때문입니다.  
이진 탐색에서는 위치를 나타내는 변수 세 가지를 사용합니다. 범위의 시작점과 끝점, 그리고 중간점입니다. 찾으려는 데이터의 중간점 위치에 있는 데이터를 반복적으로 비교해서 원하는 데이터를 찾는 것입니다. 이때 중간점은 시작점과 끝점의 인덱스를 더하고 반으로 나누고 소수점 아래를 버립니다. 한 번 확인할 떄마다 확인하는 원소의 개수가 절반씩 줄어들기 때문에 시간 복잡도는 $O\left(\log N\right)$입니다.  
## 구현 방법
이진 탐색의 구현에는 두 가지 방식이 있습니다. *재귀 함수*를 이용하는 방법과 단순하게 *반복문*을 이용하는 방법입니다.
### 재귀 함수를 이용하는 방법
```Python
def binary_search(array, target, start, end):
    if start > end:
        return None
    mid = (start + end) // 2  # 중간점
    # 찾은 경우 중간점 인덱스 반환
    if array[mid] == target:
        return mid
    # 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인
    elif array[mid] >= target:
        return binary_search(array, target, start, mid - 1)
    # 중간점의 값보다 찾고자 하는 값이 큰 경우 오른쪽 확인
    else:
        return binary_search(array, target, mid + 1, end)

# n(원소의 개수)과 target(찾고자 하는 문자열)을 입력받기
n, target = map(int, input().split())
# 전체 원소 입력받기
array = list(map(int, input().split()))

# 이진 탐색 수행 결과 출력
result = binary_search(array, target, 0, n - 1)
if result == None:
    print("원소가 존재하지 않습니다.")
else:
    print(result + 1)
```  
### 단순하게 반복문을 이용하는 방법
```Python
def binary_search(array, target, start, end):
    while start <= end:
        mid = (start + end) // 2  # 중간점
        # 찾은 경우 중간점 인덱스 반환
        if array[mid] == target:
            return mid
        # 중간점의 값보다 찾고자 하는 값이 작은 경우 왼쪽 확인
        elif array[mid] >= target:
            end = mid - 1
        # 중간점의 값보다 찾고자 하는 값이 큰 경우 오른쪽 확인
        else:
            start = mid - 1
    return None

# n(원소의 개수)과 target(찾고자 하는 문자열)을 입력받기
n, target = map(int, input().split())
# 전체 원소 입력받기
array = list(map(int, input().split()))

# 이진 탐색 수행 결과 출력
result = binary_search(array, target, 0, n - 1)
if result == None:
    print("원소가 존재하지 않습니다.")
else:
    print(result + 1)
```  
### 코딩 테스트에서의 이진 탐색
이렇게만 보면 단순해 보이지만, 사실 참고할 소스코드가 없는 상황에서 이진 탐색의 소스코드를 구현하는 것은 결코 만만하지 않습니다. 실제로 구현하기가 까다롭다는 의견도 많고요. 그래서 처음 이진 탐색을 접했다면 여러 차례 코드를 손으로 직접 타이핑하면서 익혀야 합니다. 이진 탐색은 코딩 테스트 단골 유형이니 아예 외우는 것도 좋습니다.  
또한 이진 탐색의 원리는 다른 알고리즘에서도 조금씩 변형만 되어 폭넓게 적용됩니다. 높은 난이도의 문제라면 다른 알고리즘과 함께 사용되기도 합니다. 실제로 한 대회에서는 그리디 알고리즘과 이진 탐색 알고리즘을 모두 사용해야 풀 수 있는 문제가 출제되기도 했습니다. 난이도도 높을 뿐더러 구현할 코드량이 많아 실수하기도 쉽습니다. 이진 탐색 알고리즘의 소스코드라도 확실하게 알고 있으면 문제 풀기가 조금은 쉬워집니다.  
참고로 코딩 테스트의 이진 탐색 유형은 탐색 범위가 큰 상황에서의 탐색을 가정하는 문제가 많습니다. 탐색 범위가 2,000만을 넘어간다면 이진 탐색으로 접근하는 것을 고려해보세요. 꼭 이진 탐색이 아니더라도, 처리할 데이터의 개수가 1,000만을 넘어가면 이진 탐색과 마찬가지로 시간 복잡도 $O\left(\log N\right)$을 보장하는 알고리즘을 이용하는 경우가 많습니다.

## 트리 자료구조
이진 탐색을 사용할 수 있는 조건은 데이터가 정렬되어 있는 것이라고 했죠? 데이터베이스의 경우 내부적으로 대용량 데이터 처리에 적합한 트리(tree) 자료구조를 사용하기 때문에 항상 데이터가 정렬되어 있습니다. 따라서 DB에서의 탐색은 이진 탐색과는 조금 다르지만, 이진 탐색과 유사한 방법을 이용해 탐색을 항상 빠르게 수행하도록 설계되어 있습니다.  
이후의 내용은 tree 디렉터리의 이론 파트를 참고하세요.  