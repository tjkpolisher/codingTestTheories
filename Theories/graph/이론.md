# 그래프 개념
그래프(graph)는 노드(node, 정점(vertex)라고도 함)와 간선(edge)을 이용한 비선형 데이터 구조입니다. 그래프는 주로 데이터 간의 관계를 표현하는 데 사용합니다. 각각의 데이터를 노드로, 노드 간의 관계와 흐름을 간선으로 표현합니다. 또한 관계의 정도를 표현할 필요가 있다면 가중치라는 개념을 추가해 표현합니다.
## 그래프의 특징과 종류
그래프는 방향성, 가중치, 순환성에 따라 종류가 구분됩니다.
### 방향성
간선에는 방향이 있을 수도 있고 없을 수도 있습니다. 간선에 방향이 있는 그래프를 방향 그래프(directed graph), 그렇지 않다면 무방향 그래프(undirected graph)라고 합니다.  
방향 그래프에서는 어느 한쪽으로만 간선이 있는 것이 아니라 서로 반대를 가리키는 간선이 있을 수도 있습니다.
### 가중치
어떤 데이터는 흐름의 방향뿐 아니라 그 방향으로 흘러가는 양도 중요합니다. 그 양의 정도를 간선에 표현한 것이 가중치(weight)입니다. 가중치를 갖는 그래프를 가중치 그래프(weight graph)라고 합니다.
### 순환성
순환이란 특정 노드에서 시작해 간선을 따라 다시 돌아오는 경로가 있다는 뜻입니다. 순환이 존재하는 그래프를 순환 그래프(cycle graph)라 하고, 순환이 존재하지 않는 그래프를 비순환 그래프(acyclic graph)라고 합니다.

## 그래프의 구현
그래프를 구현하는 방식에는 **인접 행렬**(adjacency matrix)과 **인접 리스트**(adjacency list)가 있습니다.
### 인접 행렬 방식
인접 행렬 방식은 2차원 배열에 각 노드가 연결된 형태를 기록하는 방식입니다. 파이썬의 경우 2차원 리스트로 구현할 수 있겠죠? 연결된 노드끼리의 가중치를 해당 행과 열의 위치에 저장합니다. 예를 들어 0번 노드에서 1번 노드로 가는 간선의 가중치가 7이라 하면 0행 1열 인덱스의 값은 7이 됩니다. 연결이 되어 있지 않은 노드들 간의 값은 무한으로 설정합니다. 실제로는 적당히 큰 값(예를 들어 999999999 등)을 무한으로 설정해서 초기화합니다. 또한 자기 자신에 대한 값은 0으로 취급합니다.

### 인접 리스트 방식
인접 리스트로 그래프를 표현할 때는 적절한 노들르 정의해야 합니다. 하나의 노드에 값, 가중치, 다음 노드의 정보를 묶어서 저장합니다. 트리에서 포인터를 이용하는 방식을 봤다면 익숙할 수 있을 겁니다.  
컴퓨터과학에서 이론상 인접 리스트는 *연결 리스트*라는 자료구조를 사용하는데, 파이썬의 리스트가 바로 이 연결 리스트에 적합합니다. 그러니 우리는 다른 추가 조치 없이 2차원 리스트를 사용하면 구현할 수 있습니다.  
인접 리스트 방식은 아래의 과정으로 동작합니다.  
1. 노드 개수만큼 배열을 준비한다.
2. 배열의 인덱스는 각 시작 노드를 의미하며, 배열의 값에 다음 노드를 연결한다.

### 두 구현 방식의 비교
메모리 측면에서는 인접 리스트 방식이 앞섭니다. 왜냐하면 인접 행렬 방식에는 간선의 유무와 무관하게 모든 노드의 관계를 저장하기 때문이죠. 노드가 많아질수록 낭비되는 메모리도 많아질 가능성이 높습니다. 반면 인접 리스트는 연결된 정보만 저장하기 때문에 메모리 면에서 효율적입니다.  
반대로 시간적인 측면에서는 인접 행렬이 더 효율적입니다. 앞서 인접 리스트가 연결된 정보만 저장한다는 특성이 여기서는 반대로 작용합니다. 특정한 두 노드가 연결되어 있는지에 대한 정보를 얻으려면 리스트를 다 뒤져야 하기 때문이죠.  
표로 정리하면 아래와 같습니다.  

||인접 행렬|인접 리스트|
|---|---|---|
|메모리 사용|$O\left(N^2\right)$|$O\left(N^2\right)$|
|시간 복잡도|$O\left(1\right)$|$O\left(N\right)$|
|기타|구현이 상대적으로 쉬움|-|  

코딩 테스트에서는 보통 주어진 시간 안에 구현을 하기 위해 인접 행렬 방식으로 그래프 문제를 푸는 경우가 많습니다. 다만, 노드 개수가 1000개 미만으로 주어지는 경우 인접 행렬이 효율적입니다.

# 그래프 탐색
탐색(search)은 많은 양의 데이터 중 자신이 원하는 데이터를 찾는 작업입니다. 대표적인 탐색 알고리즘으로는 DFS와 BFS를 꼽을 수 있습니다. 그리고 이 두 가지 알고리즘을 잘 이해해야만 코딩 테스트의 탐색 문제를 풀 수 있습니다.  
DFS와 BFS를 제대로 이해하기 위해서는 **스택과 큐 자료구조에 대한 이해가 선행되어야 합니다**.  
스택과 큐를 사용할 때는 삽입과 삭제를 구현하는 것뿐만 아니라 오버플로(overflow)와 언더플로(underflow)를 고려해야 합니다. 오버플로는 자료구조가 수용할 수 있는 데이터의 크기를 넘어서 데이터가 넘쳐흐르는 상황입니다. 반대로 언더플로는 자료구조에 데이터가 전혀 들어있지 않은 상태에서 삭제를 수행했을 때 발생하는 상황입니다. 파이썬에서 이 두 자료구조를 구현할 때는 굳이 자료구조의 크기를 지정하지 않아도 동적으로 크기를 지정하기 때문에 오버플로 문제는 잘 발생하지 않습니다. 오히려 알고리즘을 코드로 옮길 때 실수가 생겨서 빈 자료구조에서 데이터를 꺼내려하면 언더플로에 더 신경을 써야 합니다. 

## 재귀 함수
DFS와 BFS를 구현할 때는 재귀 함수(recursive function)도 알아두는 것이 좋습니다. 재귀 함수란 **자기 자신을 다시 호출하는 함수**를 뜻합니다. 따로 조건을 주지 않는 한 무한히 재귀 함수가 호출되기 때문에, 웬만한 프로그래밍 언어에는 재귀의 *최대 깊이*라는 것을 지정합니다. 쉽게 말해 재귀 함수의 호출 제한 횟수라고 보면 됩니다. 재귀 최대 깊이를 차치하더라도, 일반적으로 무한 호출 상황을 방지하기 위해 재귀 함수에 종료 조건을 걸어줍니다.  
재귀 함수의 대표적인 예로 팩토리얼(factorial) 문제가 있습니다. 수학에서 팩토리얼은 느낌표(!)로 표시하며 아래와 같이 정의합니다.  
$$n! = 1\times 2\times\cdots \left(n-1\right)\times n$$  
수학적으로 $0!=1!=1$이라는 성질이 있습니다. 이 성질을 종료 조건으로 삼으면 팩토리얼을 재귀 함수로 구현할 수 있습니다.  
```Python
def factorial(n):
    if n <= 1:
        return 1
    return n * factorial(n - 1)
```  
재귀 함수의 코드가 이렇게 간결한 이유는 수학의 점화식(재귀식)을 코드로 옮긴 것이기 때문입니다. 점화식의 개념은 이후 다이나믹 프로그래밍에서도 다시 등장하고 중요하게 사용됩니다.  
## DFS
Depth-First Search. 깊이 우선 탐색이라는 뜻입니다. 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘입니다.  
DFS에서는 시작 노드부터 탐색을 시작해 간선을 따라 최대 깊이 노드까지 이동하며 방문합니다. 최대 깊이 노드까지 방문한 후에는 이전에 방문한 노드를 거슬러 올라가며 해당 노드와 연결된 노드 중 방문하지 않은 노드로 다시 최대 깊이까지 차례대로 방문합니다. 핵심은 **가장 깊은 노드까지 방문 후에 더 이상 방문할 노드가 없으면 최근 방문한 노드로 돌아온 다음, 해당 노드에서 방문할 노드가 있는지 확인**하는 것입니다.  
DFS는 스택 자료구조를 이용합니다. 구체적인 절차는 아래와 같습니다.  
1. 시작 노드를 결정한 후 스택에 시작 노드를 푸시한다.
2. 스택이 비었는지 확인하고, 비어있으면 탐색을 종료한다.
3. 스택에서 노드를 팝한다.
4. 팝한 노드의 방문 여부를 확인하고, 아직 방문하지 않았다면 방문 처리한다.
5. 방문한 노드와 인접한 모든 노드를 확인해 그 중 아직 방문하지 않은 노드를 스택에 푸시한다.  

여기서 탐색하고 있는 방향의 반대 방향으로 돌아가는 동작이 있죠? 이 동작을 백트래킹(backtracking)이라고 합니다. 스택은 최근에 푸시한 노드부터 팝하기 때문에 특정 노드를 방문하기 전에 최근 방문 노드를 팝 연산으로 확인할 수 있습니다.  
DFS가 스택을 이용한다는 알고리즘을 고려하면 재귀 함수를 이용해 간결하게 구현할 수 있습니다.  
```Python
def dfs(graph, v, visited):
    # 현재 노드를 방문 처리
    visited[v] = True
    print(v, end=' ')
    # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[v]:
        if not visited[i]:
            dfs(graph, i, visited)
# 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
graph = [
    [],
    [2, 3, 8],
    [1, 7],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8].
    [1, 7]
]
# 각 노드의 방문 여부를 리스트 자료형으로 표현(1차원 리스트)
visited = [False] * 9
# 정의된 dfs 함수 호출
dfs(graph, 1, visited)
```  
## BFS
Breadth First Search. 너비 우선 탐색으로, 시작 노드로부터 가장 가까운 노드부터 탐색하는 알고리즘입니다. 여기서 거리는 시작 노드와 목표 노드까지의 차수입니다(트리에서 말했던 그 차수와 같은 뜻입니다!).  
최대한 먼 노드부터 탐색하는 DFS와 반대로 BFS는 가장 가까운 노드부터 탐색하는 특성으로 인해 스택 대신 **큐**를 이용해 구현합니다.  
1. 시작 노드를 결정한 후 큐에 시작 노드를 푸시한다.
2. 큐가 비었는지 확인하고, 비어있으면 탐색을 종료한다.
3. 큐에서 노드를 팝한다.
4. 팝한 노드와 인접한 모든 노드를 확인해 그 중 아직 방문하지 않은 노드를 큐에 푸시하고 방문 처리한다.  
```Python
from collections import deque

def bfs(graph, start, visited):
    queue = deque([start])
    # 현재 노드를 방문 처리
    visited[start] = True
    # 큐가 빌 때까지 반복
    while queue:
        # 큐에서 원소 하나를 뽑아서 출력
        v = queue.popleft()
        print(v, end=' ')
        # 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입
        for i in graph[v]:
            if not visited[i]:
                queue.append(i)
                visited[i] = True

# 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
graph = [
    [],
    [2, 3, 8],
    [1, 7],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8].
    [1, 7]
]

# 각 노드의 방문 여부를 리스트 자료형으로 표현(1차원 리스트)
visited = [False] * 9
# 정의된 bfs 함수 호출
bfs(graph, 1, visited)
```

## DFS vs. BFS
두 알고리즘의 차이를 비교하기 전에 알고리즘의 차이를 짚고 가야 합니다.  
깊이 우선 탐색은 **깊게 탐색 후 시작 노드로 되돌아옵니다.** 더 이상 탐색할 수 없으면 백트래킹을 수행해 최근 방문 노드부터 다시 탐색을 진행합니다. 따라서 백트래킹 알고리즘을 구현하거나 그래프의 사이클을 감지할 때 활용할 수 있습니다. 최단 경로를 찾는 문제가 아니라면 DFS를 우선적으로 고려하는 것이 좋다고 합니다.    
너비 우선 탐색은 **가중치가 없는 그래프에서 최단 경로를 보장합니다.** 시작 노드로부터 간선을 통해 직접 연결된 모든 노드를 먼저 방문하기 때문이죠. 이 때문에 문제의 답이 여러 개인 경우 가장 가까운 답을 찾을 때 유용합니다. 이를 활용하면 미로 찾기 문제의 최단 경로를 찾거나, 네트워크 분석 문제에 활용할 수 있다고 합니다.  
일반적으로 실제 수행 시간은 DFS보다 BFS가 상대적으로 덜 걸립니다.