# 그래프 개념
그래프(graph)는 노드(node, 정점(vertex)라고도 함)와 간선(edge)을 이용한 비선형 데이터 구조입니다. 그래프는 주로 데이터 간의 관계를 표현하는 데 사용합니다. 각각의 데이터를 노드로, 노드 간의 관계와 흐름을 간선으로 표현합니다. 또한 관계의 정도를 표현할 필요가 있다면 가중치라는 개념을 추가해 표현합니다.
## 그래프의 특징과 종류
그래프는 방향성, 가중치, 순환성에 따라 종류가 구분됩니다.
### 방향성
간선에는 방향이 있을 수도 있고 없을 수도 있습니다. 간선에 방향이 있는 그래프를 방향 그래프(directed graph), 그렇지 않다면 무방향 그래프(undirected graph)라고 합니다.  
방향 그래프에서는 어느 한쪽으로만 간선이 있는 것이 아니라 서로 반대를 가리키는 간선이 있을 수도 있습니다.
### 가중치
어떤 데이터는 흐름의 방향뿐 아니라 그 방향으로 흘러가는 양도 중요합니다. 그 양의 정도를 간선에 표현한 것이 가중치(weight)입니다. 가중치를 갖는 그래프를 가중치 그래프(weight graph)라고 합니다.
### 순환성
순환이란 특정 노드에서 시작해 간선을 따라 다시 돌아오는 경로가 있다는 뜻입니다. 순환이 존재하는 그래프를 순환 그래프(cycle graph)라 하고, 순환이 존재하지 않는 그래프를 비순환 그래프(acyclic graph)라고 합니다.

## 그래프의 구현
그래프를 구현하는 방식에는 **인접 행렬**(adjacency matrix)과 **인접 리스트**(adjacency list)가 있습니다. 각각의 방식을 설명하기 위해 아래 그림과 같은 그래프를 예시로 설명하겠습니다.  
![그래프 예시](dfs_bfs_example_graph.png)  
위 그래프에서 각 노드와 간선의 관계를 표로 나타내면 아래와 같습니다.  

<table>
	<tbody>
		<tr>
			<td>&nbsp;</td>
			<td><strong>0</strong></td>
			<td><strong>1</strong></td>
			<td><strong>2</strong></td>
		</tr>
		<tr>
			<td><strong>0</strong></td>
			<td>0</td>
			<td>7</td>
			<td>5</td>
		</tr>
		<tr>
			<td><strong>1</strong></td>
			<td>7</td>
			<td>0</td>
			<td>무한</td>
		</tr>
		<tr>
			<td><strong>2</strong></td>
			<td>5</td>
			<td>무한</td>
			<td>0</td>
		</tr>
	</tbody>
</table>  

### 인접 행렬 방식
인접 행렬 방식은 2차원 배열에 각 노드가 연결된 형태를 기록하는 방식입니다. 파이썬의 경우 2차원 리스트로 구현할 수 있겠죠? 연결된 노드끼리의 가중치를 해당 행과 열의 위치에 저장합니다. 예를 들어 0번 노드에서 1번 노드로 가는 간선의 가중치가 7이라 하면 0행 1열 인덱스의 값은 7이 됩니다. 연결이 되어 있지 않은 노드들 간의 값은 무한으로 설정합니다. 실제로는 적당히 큰 값(예를 들어 999999999 등)을 무한으로 설정해서 초기화합니다. 또한 자기 자신에 대한 값은 0으로 취급합니다.  
```Python
INF = 999999999 # 무한대의 비용

graph = [
    [0, 7, 5],
    [7, 0, INF],
    [5, INF, 0]
]

print(graph)
```

### 인접 리스트 방식
인접 리스트로 그래프를 표현할 때는 적절한 노드를 정의해야 합니다. 하나의 노드에 값, 가중치, 다음 노드의 정보를 묶어서 저장합니다. 트리에서 포인터를 이용하는 방식을 봤다면 익숙할 수 있을 겁니다.  
컴퓨터과학에서 이론상 인접 리스트는 *연결 리스트*라는 자료구조를 사용하는데, 파이썬의 리스트가 바로 이 연결 리스트에 적합합니다. 그러니 우리는 다른 추가 조치 없이 2차원 리스트를 사용하면 구현할 수 있습니다.  
인접 리스트 방식은 아래의 과정으로 동작합니다.  
1. 노드 개수만큼 배열을 준비한다.
2. 배열의 인덱스는 각 시작 노드를 의미하며, 배열의 값에 다음 노드를 연결한다.  

```Python
# 행이 3개인 2차원 리스트로 인접 리스트 표현
graph = [[] for _ in range(3)]

# 노드 0에 연결된 노드 정보 저장(노드, 거리)
graph[0].append((1, 7))
graph[0].append((2, 5))

# 노드 1에 연결된 노드 정보 저장(노드, 거리)
graph[1].append((0, 7))

# 노드 2에 연결된 노드 정보 저장(노드, 거리)
graph[2].append((0, 5))

print(graph)
```  

### 두 구현 방식의 비교
메모리 측면에서는 인접 리스트 방식이 앞섭니다. 왜냐하면 인접 행렬 방식에는 간선의 유무와 무관하게 모든 노드의 관계를 저장하기 때문이죠. 노드가 많아질수록 낭비되는 메모리도 많아질 가능성이 높습니다. 반면 인접 리스트는 연결된 정보만 저장하기 때문에 메모리 면에서 효율적입니다.  
반대로 시간적인 측면에서는 인접 행렬이 더 효율적입니다. 앞서 인접 리스트가 연결된 정보만 저장한다는 특성이 여기서는 반대로 작용합니다. 특정한 두 노드가 연결되어 있는지에 대한 정보를 얻으려면 리스트를 다 뒤져야 하기 때문이죠.  
표로 정리하면 아래와 같습니다.  

||인접 행렬|인접 리스트|
|---|---|---|
|메모리 사용|$O\left(N^2\right)$|$O\left(N^2\right)$|
|시간 복잡도|$O\left(1\right)$|$O\left(N\right)$|
|기타|구현이 상대적으로 쉬움|-|  

코딩 테스트에서는 보통 주어진 시간 안에 구현을 하기 위해 인접 행렬 방식으로 그래프 문제를 푸는 경우가 많습니다. 다만, 노드 개수가 1000개 미만으로 주어지는 경우에만 인접 행렬이 효율적입니다.

# 그래프 탐색
탐색(search)은 많은 양의 데이터 중 자신이 원하는 데이터를 찾는 작업입니다. 대표적인 탐색 알고리즘으로는 DFS와 BFS를 꼽을 수 있습니다. 그리고 이 두 가지 알고리즘을 잘 이해해야만 코딩 테스트의 탐색 문제를 풀 수 있습니다.  

> DFS와 BFS를 제대로 이해하기 위해서는 **스택과 큐 자료구조에 대한 이해가 선행되어야 합니다**.  

스택과 큐를 사용할 때는 삽입과 삭제를 구현하는 것뿐만 아니라 오버플로(overflow)와 언더플로(underflow)를 고려해야 합니다. 오버플로는 자료구조가 수용할 수 있는 데이터의 크기를 넘어서 데이터가 넘쳐흐르는 상황입니다. 반대로 언더플로는 자료구조에 데이터가 전혀 들어있지 않은 상태에서 삭제를 수행했을 때 발생하는 상황입니다. 파이썬에서 이 두 자료구조를 구현할 때는 굳이 자료구조의 크기를 지정하지 않아도 동적으로 크기를 지정하기 때문에 오버플로 문제는 잘 발생하지 않습니다. 오히려 알고리즘을 코드로 옮길 때 실수가 생겨서 빈 자료구조에서 데이터를 꺼내려하면 언더플로에 더 신경을 써야 합니다. 

## 재귀 함수
DFS와 BFS를 구현할 때는 재귀 함수(recursive function)도 알아두는 것이 좋습니다. 재귀 함수란 **자기 자신을 다시 호출하는 함수**를 뜻합니다. 따로 조건을 주지 않는 한 무한히 재귀 함수가 호출되기 때문에, 웬만한 프로그래밍 언어에는 재귀의 *최대 깊이*라는 것을 지정합니다. 쉽게 말해 재귀 함수의 호출 제한 횟수라고 보면 됩니다. 재귀 최대 깊이를 차치하더라도, 일반적으로 무한 호출 상황을 방지하기 위해 재귀 함수에 종료 조건을 걸어줍니다.  
재귀 함수의 대표적인 예로 팩토리얼(factorial) 문제가 있습니다. 수학에서 팩토리얼은 느낌표($!$)로 표시하며 아래와 같이 정의합니다.  
$$n! = 1\times 2\times\cdots \left(n-1\right)\times n$$  
수학적으로 $0!=1!=1$이라는 성질이 있습니다. 이 성질을 종료 조건으로 삼으면 팩토리얼을 재귀 함수로 구현할 수 있습니다.  
```Python
def factorial(n):
    if n <= 1:
        return 1
    return n * factorial(n - 1)
```  
재귀 함수의 코드가 이렇게 간결한 이유는 수학의 점화식(재귀식)을 코드로 옮긴 것이기 때문입니다. 점화식의 개념은 이후 *다이나믹 프로그래밍*에서도 다시 등장하고 중요하게 사용됩니다.  
## DFS
Depth-First Search. 깊이 우선 탐색이라는 뜻입니다. 그래프에서 깊은 부분을 우선적으로 탐색하는 알고리즘입니다.  
DFS에서는 시작 노드부터 탐색을 시작해 간선을 따라 최대 깊이 노드까지 이동하며 방문합니다. 최대 깊이 노드까지 방문한 후에는 이전에 방문한 노드를 거슬러 올라가며 해당 노드와 연결된 노드 중 방문하지 않은 노드로 다시 최대 깊이까지 차례대로 방문합니다. 핵심은 **가장 깊은 노드까지 방문 후에 더 이상 방문할 노드가 없으면 최근 방문한 노드로 돌아온 다음, 해당 노드에서 방문할 노드가 있는지 확인**하는 것입니다.  
DFS는 **스택** 자료구조를 이용합니다. 구체적인 절차는 아래와 같습니다.  
1. 시작 노드를 결정한 후 스택에 시작 노드를 푸시한다.
2. 스택이 비었는지 확인하고, 비어있으면 탐색을 종료한다.
3. 스택에서 노드를 팝한다.
4. 팝한 노드의 방문 여부를 확인하고, 아직 방문하지 않았다면 방문 처리한다.
5. 방문한 노드와 인접한 모든 노드를 확인해 그 중 아직 방문하지 않은 노드를 스택에 푸시한다.  

여기서 탐색하고 있는 방향의 반대 방향으로 돌아가는 동작이 있죠? 이 동작을 **백트래킹**(backtracking)이라고 합니다. 스택은 최근에 푸시한 노드부터 팝하기 때문에 특정 노드를 방문하기 전에 최근 방문 노드를 팝 연산으로 확인할 수 있습니다.  
DFS가 스택을 이용한다는 알고리즘을 고려하면 재귀 함수를 이용해 간결하게 구현할 수 있습니다.  
```Python
def dfs(graph, v, visited):
    # 현재 노드를 방문 처리
    visited[v] = True
    print(v, end=' ')
    # 현재 노드와 연결된 다른 노드를 재귀적으로 방문
    for i in graph[v]:
        if not visited[i]:
            dfs(graph, i, visited)
# 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
graph = [
    [],
    [2, 3, 8],
    [1, 7],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8].
    [1, 7]
]
# 각 노드의 방문 여부를 리스트 자료형으로 표현(1차원 리스트)
visited = [False] * 9
# 정의된 dfs 함수 호출
dfs(graph, 1, visited)
```  
## BFS
Breadth First Search. 너비 우선 탐색으로, 시작 노드로부터 가장 가까운 노드부터 탐색하는 알고리즘입니다. 여기서 거리는 시작 노드와 목표 노드까지의 차수입니다(트리에서 말했던 그 차수와 같은 뜻입니다!).  
최대한 먼 노드부터 탐색하는 DFS와 반대로 BFS는 가장 가까운 노드부터 탐색하는 특성으로 인해 스택 대신 **큐**를 이용해 구현합니다.  
1. 시작 노드를 결정한 후 큐에 시작 노드를 푸시한다.
2. 큐가 비었는지 확인하고, 비어있으면 탐색을 종료한다.
3. 큐에서 노드를 팝한다.
4. 팝한 노드와 인접한 모든 노드를 확인해 그 중 아직 방문하지 않은 노드를 큐에 푸시하고 방문 처리한다.  
```Python
from collections import deque

def bfs(graph, start, visited):
    queue = deque([start])
    # 현재 노드를 방문 처리
    visited[start] = True
    # 큐가 빌 때까지 반복
    while queue:
        # 큐에서 원소 하나를 뽑아서 출력
        v = queue.popleft()
        print(v, end=' ')
        # 해당 원소와 연결된, 아직 방문하지 않은 원소들을 큐에 삽입
        for i in graph[v]:
            if not visited[i]:
                queue.append(i)
                visited[i] = True

# 각 노드가 연결된 정보를 리스트 자료형으로 표현(2차원 리스트)
graph = [
    [],
    [2, 3, 8],
    [1, 7],
    [1, 4, 5],
    [3, 5],
    [3, 4],
    [7],
    [2, 6, 8].
    [1, 7]
]

# 각 노드의 방문 여부를 리스트 자료형으로 표현(1차원 리스트)
visited = [False] * 9
# 정의된 bfs 함수 호출
bfs(graph, 1, visited)
```

## DFS vs. BFS
두 알고리즘의 차이를 비교하기 전에 알고리즘의 차이를 짚고 가야 합니다.  
깊이 우선 탐색은 **깊게 탐색 후 시작 노드로 되돌아옵니다.** 더 이상 탐색할 수 없으면 백트래킹을 수행해 최근 방문 노드부터 다시 탐색을 진행합니다. 따라서 백트래킹 알고리즘을 구현하거나 그래프의 사이클을 감지할 때 활용할 수 있습니다. 최단 경로를 찾는 문제가 아니라면 DFS를 우선적으로 고려하는 것이 좋다고 합니다.    
너비 우선 탐색은 **가중치가 없는 그래프에서 최단 경로를 보장합니다.** 시작 노드로부터 간선을 통해 직접 연결된 모든 노드를 먼저 방문하기 때문이죠. 이 때문에 문제의 답이 여러 개인 경우 가장 가까운 답을 찾을 때 유용합니다. 이를 활용하면 미로 찾기 문제의 최단 경로를 찾거나, 네트워크 분석 문제에 활용할 수 있다고 합니다.  
일반적으로 실제 수행 시간은 DFS보다 BFS가 상대적으로 덜 걸립니다.

# 다른 그래프 알고리즘
DFS/BFS, 그리고 최단 경로 알고리즘 말고도 그래프 관련 알고리즘은 굉장히 다양합니다. 출제 비중은 낮은 편이지만 꼭 제대로 알아야 합니다. 하지만 대부분이 다른 알고리즘에 기반하고 있다는 점을 이해하고 있으면 부담이 조금 덜할 것입니다.
## 서로소 집합
Disjoint sets. 수학에서 서로소 집합이란 공통 원소가 없는 두 집합을 의미합니다. 예를 들어 두 집합 $\left\{1, 2\right\}$와 $\left\{3, 4\right\}$는 교집합이 없기 때문에 서로소 집합입니다.  
이를 응용한 서로소 집합 자료구조를 그래프 자료구조에서 유용하게 사용할 수 있습니다. 서로소 집합 자료구조는 **서로소 부분집합들로 나누어진 원소들의 데이터를 처리하기 위한 자료구조**입니다. 이 자료구조는 union과 find라는 두 연산으로 조작할 수 있습니다.  
- union: 합집합 연산. 두 원소가 포함된 집합을 하나의 집합으로 합치는 연산.
- find: 찾기 연산. 특정한 원소가 속한 집합이 어떤 집합인지 알려주는 연산

이 두 가지 연산에서 이름을 따 서로소 집합 자료구조를 union-find 자료구조라고 부르기도 합니다.  
서로소 집합 자료구조는 트리를 이용하여 집합을 표현합니다. 서로소 집합 정보(합집합 연산)가 주여졌을 때 트리 자료구조를 이용해 집합을 표현하는 서로 집합 계산 알고리즘은 아래와 같습니다.  
1. union 연산을 확인하여, 서로 연결된 두 노드 A, B를 확인한다.
    1. A와 B의 루트 노드 A'와 B'를 각각 찾는다.
    2. A'를 B'의 부모 노드로 설정해 B'가 A'을 가리키도록 한다.
2. 모든 union 연산을 처리할 때까지 1번 과정을 반복한다.

실제 구현할 때는 A'와 B' 중 더 번호가 작은 원소가 부모 노드가 되도록 하는 경우가 많습니다. 예를 들어 A'가 1이고, B'가 3이라면, B'가 A'를 가리키도록 하는 것이죠. 여기서 '가리킨다'는 표현은 '부모 노드로 설정한다'는 뜻으로 이해하면 됩니다.  
### 예시
전체 집합 $\left\{1, 2, 3, 4, 5, 6\right\}$이 주여져 있습니다. 이때 다음과 같이 4개의 union 연산을 수행한다고 해보겠습니다.
- union 1, 4
- union 2, 3
- union 2, 4
- union 5, 6

각각의 union 연산은 '1과 4는 같은 집합', '2와 3은 같은 집합', '2와 4는 같은 집합', '5와 6은 같은 집합'이라는 뜻입니다. 이 4개의 union 연산이 진행된 후에, 전체 원소들이 결과적으로 어떠한 형태의 부분집합으로 나뉘어질지 확인해보는 예제입니다.  
이러한 union 연산을 그래프 형태로 표현할 수 있습니다. 각 원소는 그래프에서 노드로 표현되고, '같은 집합에 속한다'는 정보를 담은 union 연산은 간선이 됩니다. 즉, 이 예제는 노드 6개와 간선 4개로 구성되는 그래프로 볼 수 있는 것이죠.  
> 주의할 점은, 그래프는 어디까지나 union의 관계를 효과적으로 보여주기 위해 그래프 형태로 시각화할 수 있음을 보여주기 위해 도입한 것입니다. 실제로 각 정보의 집합 정보를 표현할 때는 트리를 이용해야 합니다.
#### 0단계: 부모 테이블 초기화
먼저 크기가 노드의 개수 $V$와 같은 부모 테이블을 초기화합니다. 이때 모든 원소가 자기 자신을 부모로 가지도록 설정합니다. 현재 원소가 6개이므로, 0단계 시점에서는 총 6개의 트리가 존재하는 것과 같습니다.  
부모 테이블은 말 그대로 부모에 대한 정보만을 담고 있습니다. 다시 말해 특정 노드의 부모에 대해서만 저장하는 것입니다. 우리가 실제로 루트를 확인하려면 재귀적으로 부모를 거슬러 올라가 최종적인 루트 노드를 찾아야 합니다.  

<table>
	<tbody>
		<tr>
			<td><strong>노드 번호</strong></td>
			<td>1</td>
			<td>2</td>
			<td>3</td>
			<td>4</td>
			<td>5</td>
			<td>6</td>
		</tr>
		<tr>
			<td><strong>부모</strong></td>
			<td>1</td>
			<td>2</td>
			<td>3</td>
			<td>4</td>
			<td>5</td>
			<td>6</td>
		</tr>
	</tbody>
</table>

#### 1단계: union 1, 4
첫 번째 union 연산에서는 1과 4를 합칩니다. 이때 노드 1과 노드 4의 루트 노드를 각각 찾으면 됩니다. 현재 루트 노드는 각각 1와 4이기 때문에 더 큰 번호에 해당하는 노드 4의 부모를 1로 설정합니다.  
<table>
	<tbody>
		<tr>
			<td><strong>노드 번호</strong></td>
			<td>1</td>
			<td>2</td>
			<td>3</td>
			<td>4</td>
			<td>5</td>
			<td>6</td>
		</tr>
		<tr>
			<td><strong>부모</strong></td>
			<td>1</td>
			<td>2</td>
			<td>3</td>
			<td>1</td>
			<td>5</td>
			<td>6</td>
		</tr>
	</tbody>
</table>  

#### 2단계: union 2, 3
노드 2와 3을 합칩니다. 현재 루트 노드는 각각 2와 3이기 때문에 더 큰 번호에 해당하는 노드 3의 부모를 2로 설정합니다.  

<table>
	<tbody>
		<tr>
			<td><strong>노드 번호</strong></td>
			<td>1</td>
			<td>2</td>
			<td>3</td>
			<td>4</td>
			<td>5</td>
			<td>6</td>
		</tr>
		<tr>
			<td><strong>부모</strong></td>
			<td>1</td>
			<td>2</td>
			<td>2</td>
			<td>1</td>
			<td>5</td>
			<td>6</td>
		</tr>
	</tbody>
</table>

#### 3단계: union 2, 4
노드 2와 4의 루트 노드를 각각 찾습니다. 현재 루트 노드가 각각 2와 1이기 때문에 더 큰 번호인 루트 노드 2의 부모를 1로 설정합니다.  

<table>
	<tbody>
		<tr>
			<td><strong>노드 번호</strong></td>
			<td>1</td>
			<td>2</td>
			<td>3</td>
			<td>4</td>
			<td>5</td>
			<td>6</td>
		</tr>
		<tr>
			<td><strong>부모</strong></td>
			<td>1</td>
			<td>1</td>
			<td>2</td>
			<td>1</td>
			<td>5</td>
			<td>6</td>
		</tr>
	</tbody>
</table>

#### 4단계: union 5, 6
마지막으로 노드 5와 6을 합칩니다. 루트 노드 6의 부모를 5로 설정합니다.  

<table>
	<tbody>
		<tr>
			<td><strong>노드 번호</strong></td>
			<td>1</td>
			<td>2</td>
			<td>3</td>
			<td>4</td>
			<td>5</td>
			<td>6</td>
		</tr>
		<tr>
			<td><strong>부모</strong></td>
			<td>1</td>
			<td>1</td>
			<td>2</td>
			<td>1</td>
			<td>5</td>
			<td>5</td>
		</tr>
	</tbody>
</table>

이렇게 모든 union 연산을 처리했습니다. 이 알고리즘에서 유의할 점은 항상 부모 테이블을 가지고 있어야 한다는 점입니다. 또한 루트 노드를 즉시 계산할 수 없고, 부모 테이블을 계속 확인하며 거슬러 올라가야 합니다. 예를 들어 4단계의 경우 노드 3의 부모 노드는 2로 설정되어 있습니다. 하지만 노드 2의 부모 노드는 1이기 때문에 최종적으로 노드 3의 루트 노드는 1이라고 볼 수 있습니다. 다시 말해 **서로소 집합 알고리즘으로 루트 노드를 찾기 위해서는 재귀적으로 부모를 거슬러 올라가야 합니다.**

### 서로소 집합 소스 코드
이제 이 예시에서 나온 알고리즘을 소스 코드로 작성해보겠습니다.  
```Python
# 특정 원소가 속한 집합을 찾기
def find_parent(parent, x):
    # 루트 노드가 아니라면, 루트 노드를 찾을 때까지 재귀 호출
    if parent[x] != x:
        return find_parent(parent, parent[x])
    return x


# 두 원소가 속한 집합을 합치기
def union_parent(parent, a, b):
    a = find_parent(parent, a)
    b = find_parent(parent, b)
    if a < b:
        parent[b] = a
    else:
        parent[a] = b


# 노드의 개수와 간선(union 연산)의 개수 입력받기
v, e = map(int, input().split())
parent = [0] * (v + 1)  # 부모 테이블 초기화

# 부모 테이블 상에서, 부모를 자기 자신으로 초기화
for i in range(1, v + 1):
    parent[i] = i

# union 연산을 각각 수행
for i in range(e):
    a, b = map(int, input().split())
    union_parent(parent, a, b)

# 각 원소가 속한 집합 출력
print('각 원소가 속한 집합: ', end='')
for i in range(1, v + 1):
    print(find_parent(parent, i), end=' ')

print()

# 부모 테이블 내용 출력
print('부모 테이블: ', end='')
for i in range(1, v + 1):
    print(parent[i], end=' ')
```  
다만, 이렇게 구현하면 `find_parent` 함수가 비효율적으로 동작합니다. 최악의 경우 함수가 모든 노드를 다 확인하기 때문에 시간 복잡도가 $O\left(V\right)$입니다. 더 확장하자면, $M$개의 간선에 대해서 find 혹은 union 함수를 적용할 경우 시간 복잡도는 $O\left(VM\right)$이 되어 비효율적입니다.  
### 경로 압축 기법
이러한 find 함수는 의외로 간단하게 최적화가 가능합니다. 이 기법을 **경로 압축**(path compression)이라고 합니다. find 함수를 재귀적으로 호출한 뒤에 부모 테이블 값을 갱신하는 기법입니다. 기존의 find 함수를 다음과 같이 변경하면 경로 압축 구현이 완료됩니다.  
```Python
def find_parent(parent, x):
    if parent[x] != x:
        parent[x] = find_parent(parent, parent[x])
    return parent[x]
```  
이렇게 수정하면 각 노드에 대하여 find 함수를 호출한 이후에, 해당 노드의 루트 노다가 바로 부모 노드가 됩니다. 루트 노드에 더욱 빠르게 접근할 수 있기 때문에 시간 복잡도가 개선됩니다.
### 서로소 집합 알고리즘의 시간 복잡도
노드의 개수 $V$개이고, 최대 $V-1$회의 union 연산과 $M$개의 find 연산이 가능하다고 합시다. (증명은 어려우니 생략하지만) 이때, 경로 압축만을 이용할 경우의 시간 복잡도는 $O\left(V+M\left(1+\log_{2-\frac{M}{V}}V\right)\right)$라고 알려져 있습니다. 예를 들어, 노드가 1000개이고 union 및 find 연산을 통틀어서 100만 번 수행된다고 할 경우, 대략 1000만 번 가량의 연산이 필요합니다.  
> 시간 복잡도를 줄이는 방법은 이것 말고도 더 있지만, 코딩 테스트 수준에서는 경로 압축만 적용해도 충분합니다. 개념과 구현이 간단하니 꼭 기억해둡시다!

### 서로소 집합을 활용한 사이클 판별
서로소 집합을 이용하면 무방향 그래프 내에서 사이클을 판별할  수 있습니다. 참고로 방향 그래프에서의 사이클 여부는 DFS를 이용해 판별할 수 있습니다.  
앞서 union 연산을 그래프의 간선으로 표현할 수 있다고 했죠? 따라서 간선을 하나씩 확인하면서 두 노드가 포함되어 있는 집합을 합치는 과정만 반복해도 사이클을 판별할 수 있습니다. 과정은 아래와 같습니다. 
1. 각 간선을 확인하며 두 노드의 루트 노드를 확인한다.  
    1. 루트 노드가 서로 다르다면 두 노드에 대해 union 연산을 수행한다.
    2. 루트 노드가 서로 같다면 사이클(cycle)이 발생한 것으로 판정한다.
2. 그래프에 포함되어 있는 모든 간선에 대하여 1번 과정을 반복한다.  

이 알고리즘은 그래프에 포함된 모든 간선을 하나씩 확인해, 매 간선에 대하여 union 및 find 함수를 호출하는 방식으로 동작합니다.  
> 이 알고리즘은 간선에 방향성이 없는 무방향 그래프에서만 적용 가능합니다. 