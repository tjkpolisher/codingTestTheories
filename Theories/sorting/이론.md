# 정렬 개요
정렬(Sorting)이란 **데이터를 특정한 기준에 따라서 순서대로 나열**하는 것을 말합니다. 파이썬에서 기본적으로 제공하는 정렬 함수와 정렬 라이브러리를 사용하면 좀 더 효과적으로 정렬을 수행할 수 있습니다. 하지만 정렬 알고리즘 그 자체는 *알고리즘의 효율성*을 이해하는 좋은 수단이기도 하기 때문에 알고리즘만 빡세게 다루는 책에서는 정렬을 가장 먼저 다루는 경우도 있습니다. 실전 코딩 테스트에서도 적절하지 못한 정렬 알고리즘을 사용했다가 시간을 낭비하는 케이스도 많고요. 기술 면접 단골 질문이기도 한 만큼 정렬 알고리즘 자체를 이해할 필요는 충분합니다.  
## 들어가기 전에 - 버블 정렬
실질적으로 의미 있는 정렬 알고리즘을 보기 전에 가장 원시적인 정렬 알고리즘을 소개하겠습니다. 바로 버블 정렬(Bubble sort) 알고리즘입니다. 이 방식은 첫 번째와 두 번째 원소를 비교해서 정렬하고, 두 번째와 세 번째, 계속 나아가서 $N-1$번 째와 $N$번 째를 정렬한 뒤 *다시 처음으로 돌아가* 이번에는 $n-2$번째와 $n-1$번째까지... 해서 최대 $\frac{n\left(n-1\right)}{2}$번 정렬합니다. 한 번 돌 때마다 마지막 하나가 정렬되기 때문에 이를 시각화하면 마치 원소들이 거품 올라오듯 보여서 버블 정렬이라는 이름이 붙었습니다.  
다만... 직관적이고 만들기 쉬울 뿐 거의 모든 상황에서 최악의 성능을 보여줍니다. 이미 정렬된 알고리즘이 정말로 정렬되었는지 확인하기 위해 사용한다면 모를까. 실제 개발에서는 전혀 쓰이지 않는다고 봐도 좋습니다. "버블 정렬 구현해보세요"라는 문제가 나오지 않는 이상... 그래도 굳이 코드를 작성해보자면 아래와 같이 작성할 수 있을 겁니다.  
```Python
for i in range(len(array) - 1):
    for j in range(i + 1, len(array)):
        if array[j] > array[i]:
            array[j], array[i] = array[i], array[j]
```
## 선택 정렬
데이터가 무작위로 여러 개 있을 때, 이 중 가장 작은 데이터를 선택해 맨 앞에 있는 데이터와 바꾸고, 그 다음으로 작은 데이터를 선택해 두 번째 데이터와 바꾸는 과정을 반복할 수 있을 겁니다. 이 방식을 **선택 정렬** 알고리즘(Selection sort)이라고 하며, 이 또한 원시적인 정렬 알고리즘 중 하나입니다.  
데이터의 개수를 $N$개라고 해보죠. 그러면 가장 작은 데이터를 앞으로 보내는 과정을 $N-1$번 반복하면 정렬이 완료됩니다. 파이썬으로 작성한 코드는 아래와 같을 겁니다.  
```Python
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(len(array)):
    min_index = i # 가장 작은 원소의 인덱스
    for j in range(i + 1, len(array)):
        if array[min_index] > array[j]:
            min_index = j
    array[i], array[min_index] = array[min_index], array[i] # 위치 교환(스와프, swap)

print(array)
```  
여기서 스와프(swap)란 특정한 리스트가 주어졌을 때 두 변수의 위치를 변경하는 작업을 의미합니다. 파이썬에서는 위 코드와 같이 간단하게 두 원소의 위치를 바꿀 수 있지만, 그 외의 다른 프로그래밍 언어에서는 일반적으로 임시 저장용 변수를 하나 더 만들어서 두 원소의 값을 변경해야 합니다. 더군다나 언어에 따라 별도로 스와프 함수를 만들어 둔 경우도 있긴 하지만 파이썬만큼 편리하지는 않고요.  
### 선택 정렬의 시간 복잡도
 
선택 정렬의 시간 복잡도는 $O\left(N^2\right)$입니다. 위 코드를 보면 이중 반복문이 사용되었기 때문이라고 이해할 수 있습니다. 그래서 선택 정렬을 이용할 경우 (일반적으로) 데이터의 개수가 10000개를 넘어가면서 속도가 급격히 느려집니다. 뒤에서 다룰 다른 정렬 알고리즘이나 기본 정렬 라이브러리와 비교하면 매우 비효율적입니다. ~~그래도 버블 정렬보다 두 배 정도 빠릅니다~~ 하지만 특정한 리스트에서 가장 작은 데이터를 찾는 문제가 자주 출제되니, 그 소스코드만큼은 자주 작성해서 익숙해지는 것을 권합니다.
## 삽입 정렬
![선택 정렬](https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif)  
(출처: https://upload.wikimedia.org/wikipedia/commons/9/94/Selection-Sort-Animation.gif)  
삽입 정렬(Insertion sort)은 특정한 데이터를 적절한 위치에 '삽입'하는 방식입니다. 실제 인간에게 뭔가를 정렬하라고 할 때 무의식적으로 사용하는 알고리즘이기도 합니다. 선택 정렬보다 구현 난이도는 높지만 실행 시간 측면에서는 더 효율적입니다. 특히 필요할 때만 데이터의 위치를 바꾸므로 '데이터가 거의 정렬'되어 있을 때 훨씬 효율적입니다.  
삽입 정렬은 두 번째 데이터부터 시작하는 것이 원칙입니다. 왜냐하면 첫 번째 데이터는 그 자체로 정렬되어 있다고 가정하기 때문입니다.  
또한 삽입 정렬의 특징 중 하나로, **정렬이 이루어진 원소는 항상 오름차순을 유지하고 있습니다**(내림차순으로 정렬하도록 코드를 구성했다면 반대로 정렬이 이루어진 원소들이 내림차순을 유지).  
```Python
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

for i in range(1, len(array)):
    for j in range(i, 0, -1):
        if array[j] < array[j - 1]: # 한 칸씩 왼쪽으로 이동
            array[j], array[j - 1] = array[j - 1], array[j]
        else: # 자기보다 작은 데이터를 만나면 그 위치에서 루프 정지
            break

print(array)
```  

### 삽입 정렬의 시간 복잡도
삽입 정렬도 선택 정렬과 마찬가지로 이중 반복문을 사용하기 때문에 시간 복잡도는 $O\left(N^2\right)$입니다. 다만, 앞서 말했듯이 삽입 정렬은 *데이터가 거의 정렬되어 있는 경우 더 빠르게 동작*합니다. 최선의 경우는 $O\left(N\right)$를 가집니다. 후술할 퀵 정렬 알고리즘과 비교했을 때, 보통은 삽입 정렬이 비효율적이지만 정렬이 거의 되어 있는 상황이라면 퀵 정렬보다 더 강력하다고 알려져 있습니다. 따라서 거의 정렬되어 있는 상태로 입력이 주어진다면 삽입 정렬의 사용을 고려해볼 수 있습니다.  

## 퀵 정렬
![퀵 정렬](https://www.lavivienpost.net/wp-content/uploads/2022/04/quick-sort-450.jpg)  
(출처: https://www.lavivienpost.net/wp-content/uploads/2022/04/quick-sort-450.jpg, 위 사진의 pivot 방식은 아래의 설명과 차이가 있을 수 있습니다.)  

퀵 정렬(Quick sort) 알고리즘은 가장 많이 사용되는 정렬 알고리즘입니다. 병합 정렬 알고리즘과 함께 대부분의 프로그래밍 언어에서 정렬 라이브러리의 근간을 이루는 알고리즘이기도 하죠. 영어 명칭 quick에 걸맞게 빠른 이 알고리즘의 기본 아이디어는 **기준을 설정한 다음 큰 수와 작은 수를 교환한 후 리스트를 반으로 나누는** 방식으로 동작합니다. 개념은 조금 어렵지만, 이 개념이 익숙해지면 다른 정렬 기법에 비해 소스코드도 쉽게 작성할 수 있습니다.  
앞서 퀵 정렬에서 '기준'을 설정한다고 했죠? 이 기준을 피벗(pivot)이라고 부릅니다. 퀵 정렬을 수행하려면 먼저 이 피벗을 어떻게 설정할 지를 명시해야 합니다. 피벗을 설정하는 방법에 따라서도 퀵 정렬은 여러 가지로 분류되는데, 가장 대표적인 방식은 **호어 분할**(Hoare partition) 방식입니다(퀵 정렬 알고리즘의 개발자인 토니 호어 경(Sir Tony Hoare)의 이름을 딴 방식). 이 방식의 아이디어는 아래와 같습니다.  

> 리스트에서 첫 번째 데이터를 피벗으로 정한다.

피벗을 설정한 뒤에는 왼쪽에서부터 피벗보다 큰 데이터를 찾고, 오른쪽에서부터 피벗보다 작은 데이터를 찾습니다. 그 다음 큰 데이터와 작은 데이터의 위치를 서로 교환해줍니다. 이러한 과정을 반복하면 피벗에 대하여 정렬이 수행됩니다.  
퀵 정렬 도중에 피벗보다 큰 데이터와 작은 데이터가 엇갈리는 경우가 발생하는데, 이 때 작은 데이터와 피벗의 위치를 교체해주면, 기존의 피벗을 기준으로 왼쪽에는 피벗보다 작은 값이, 오른쪽에는 피벗보다 큰 값이 배치됩니다. 이렇게 피벗의 값을 기준으로 데이터를 위치시키는 과정을 **파티션**(partition)이라고 합니다.  
이제 각각의 파티션에 대해서 위 과정을 반복해 정렬을 수행하게 됩니다. 퀵 정렬은 **현재 파티션 리스트의 데이터가 1개인 경우** 종료하게 됩니다. 이 조건을 활용해 재귀 함수 형태로 알고리즘을 작성하면 구현이 매우 간편해집니다.  
```Python
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array, start, end):
    if start >= end: # 원소가 1개인 경우 종료
        return
    pivot = start # 피벗은 첫 번째 원소
    left = start + 1
    right = end
    while left <= right:
        # 피벗보다 큰 데이터를 찾을 때까지 반복
        while left <= end and array[left] <= array[pivot]:
            left += 1
        # 피벗보다 작은 데이터를 찾을 때까지 반복
        while right > start and array[right] >= array[pivot]:
            rightt -= 1
        if left > right: # 엇갈렸다면 작은 데이터와 피벗 교체
            array[right], array[pivot] = array[pivot], array[right]
        else: # 엇갈리지 않았다면 작은 데이터와 큰 데이터 교체
            array[left], array[right] = array[left], array[right]
    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행
    quick_sort(array, start, right - 1)
    quick_sort(array, right + 1, end)

quick_sort(array, 0, len(array) - 1)
print(array)
```  
그런데, 파이썬의 장점을 살리면 조금 더 짧게 소스코드를 작성할 수도 있습니다. 더 직관적이고 기억하기 쉬운 장점이 있지만, 피벗과 데이터를 비교하는 연산 횟수가 증가해 시간 면에서는 조금 비효율적입니다.  
```Python
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

def quick_sort(array):
    # 리스트가 원소 1개만을 담고 있으면 종료
    if len(array) <= 1:
        return array
    
    pivot = array[0] # 피벗은 첫 번째 원소
    tail = array[1:] # 피벗을 제외한 리스트

    left_side = [x for x in tail if x <= pivot] # 분할된 왼쪽 부분
    right_side = [x for x in tail if x > pivot] # 분할된 오른쪽 부분

    # 분할 이후 왼쪽 부분과 오른쪽 부분에서 각각 정렬 수행, 전체 리스트 반환
    return quick_sort(left_side) + [pivot] + quick_sort(right_side)

print(quick_sort(array))
```  
### 퀵 정렬의 시간 복잡도
퀵 정렬의 *평균적인* 시간 복잡도는 $O\left(N\log N\right)$입니다. 하지만 리스트의 가장 왼쪽 데이터를 피벗으로 삼는다는 가정 하에, *이미 데이터가 정렬되어 있는 경우*와 같은 케이스에서는 최악의 경우 시간 복잡도가 $O\left(N^2\right)$가 되고 맙니다. 앞서 다룬 선택 정렬이나 삽입 정렬과는 정반대입니다.  
그래서인지 다른 프로그래밍 언어, 특히 C++와 같이 퀵 정렬을 기반으로 정렬 라이브러리를 작성해 놓은 프로그래밍 언어는 최악의 경우에도 $O\left(N\log N\right)$의 시간 복잡도를 보장하도록 피벗 설정과 파티션 분할에 추가적인 로직을 도입합니다. 우리는 그러한 노력이 있다는 사실 ~~그리고 그렇게 용을 쓰더라도 최악의 경우가 나올 수도 있다는 사실~~ 정도만 이해하고 넘어갑시다.  
파이썬에서도 정렬 라이브러리를 이용하면 이 정도 시간 복잡도를 보장하기 때문에 큰 걱정은 하지 않아도 됩니다.  

## 계수 정렬
![계수 정렬](https://upload.wikimedia.org/wikipedia/commons/d/d6/CountingSort.gif)  
(gif 출처: https://upload.wikimedia.org/wikipedia/commons/d/d6/CountingSort.gif)  
  
계수 정렬(Counting sort) 알고리즘은 가장 큰 데이터에 따라 효율이 좌지우지되는 특이한 알고리즘입니다. 특정 데이터의 개수(예를 들어, 1이 두 개 있다면 2)를 데이터의 값에 대응하는 위치에 저장한 뒤, 자신의 위치에서 앞에 있던 값을 모두 더한 배열을 만든 뒤, 거기서 데이터가 들어가야 할 위치를 찾아내는 알고리즘입니다. 데이터의 최대값을 $K$라고 하면, 이 알고리즘의 시간 복잡도는 최악의 경우 $O\left(N + K\right)$를 보장합니다. 다만, **데이터의 크기 범위가 제한되어 정수 형태로 표현할 수 있을 때만 사용이 가능**합니다. 일반적으로 최소값과 최대값의 크기 차이가 1백만을 넘지 않는 경우에 효과적이라고 알려져 있습니다.  
```Python
# 모든 원소의 값이 0 이상이라고 가정
array = [7, 5, 9, 0, 3, 1, 6, 2, 9, 1, 4, 8, 0, 5, 2]
# 모든 범위를 포함하는 리스트 선언(모든 값을 0으로 초기화)
count = [0] * (max(array) + 1)

for i in range(len(array)):
    count[array[i]] += 1 # 각 데이터에 해당하는 인덱스의 값 증가

for i in range(len(count)):
    for j in range(count[i]):
        print(i, end=' ')
```  
### 계수 정렬의 시간 복잡도
시간 복잡도에 대해 앞서 설명한 것을 조금 풀어서 설명해보겠습니다.  
정렬할 모든 데이터가 양의 정수인 상황을 가정하겠습니다. 데이터의 개수는 $N$개이고, 데이터 중 최대값의 크기는 $K$라고 놓겠습니다. 계수 정렬은 앞에서부터 데이터를 하나씩 확인하면서 리스트에서 적절한 인덱스의 값을 1씩 증가시킵니다. 여기에 더해서 데이터 중 최대값의 크기만큼 이 작업을 반복해야 하기 때문에 최종 시간 복잡도는 $O\left(N+K\right)$입니다.  
데이터의 범위만 한정되어 있다면 계수 정렬은 항상 빠르게 동작합니다. 이 때문에 현존하는 정렬 알고리즘 중 기수 정렬(radix sort)과 더불어 가장 빠르다고 알려져 있습니다.  
> 참고로 기수 정렬은 계수 정렬에 비해 동작이 상대적으로 느립니다. 하지만 처리할 수 있는 정수의 크기는 더 큽니다. 대신 알고리즘의 원리나 소스코드는 조금 더 복잡합니다. 코딩 테스트에 거의 출제되지 않는 게 참 다행이군요.  

### 계수 정렬의 *공간 복잡도*
그런데 계수 정렬은 경우에 따라 극도로 비효율적인 알고리즘으로 전락할 수 있습니다. 게다가 이 경우 시간 복잡도가 아니라 공간 복잡도에서 발목을 잡힙니다.  
데이터가 단 2개 뿐이고, 그 차이가 극도로 큰 두 정수라고 가정해보겠습니다. 예를 들어 0과 99,999라고 해보죠. 이럴 때에도 리스트의 크기가 10만 개가 되도록 선언해야 합니다. 메모리가 낭비되는 거죠. 더군다나 코딩 테스트에서는 보통 입력되는 데이터의 개수를 1,000만 개 이상으로 설정할 수 없는 경우가 많기 때문에 실제 데이터의 개수가 적더라도 그 차이가 매우 크다면 계수 정렬은 사용할 수 없을 겁니다.  
그래서 계수 정렬은 아무 때나 사용할 수 있는 정렬 알고리즘은 아니며, 동일한 값을 여러 개 가지는 데이터가 여러 개 등장할 때 적합합니다. 물론 조건만 만족한다면 정렬해야 하는 데이터의 개수가 매우 많을 때도 충분히 효과적으로 사용할 수 있습니다.  

## 파이썬 정렬 라이브러리
우리가 알고리즘 문제를 풀 때는 앞서 다뤘던 예제처럼 정렬 알고리즘을 직접 작성하게 되는 경우도 물론 있지만, 사실 미리 만들어진 라이브러리를 이용하는 게 효과적입니다.  
파이썬은 기본 정렬 라이브러리인 `sorted()` 함수를 제공합니다. 이 함수의 기본 아이디어는 퀵 정렬과 방식이 비슷한 **병합 정렬**(merge sort)입니다. 일반적으로 병합 정렬은 퀵 정렬보다 느리지만, 최악의 경우에도 시간 복잡도 $O\left(N\log N\right)$을 보장한다는 특징입니다. 이러한 병합 정렬과 삽입 정렬의 아이디어를 통합한 하이브리드 알고리즘이 되겠습니다. 비단 파이썬뿐만 아니라 대부분의 프로그래밍 언어에서 제공하는 정렬 함수가 병합 정렬 혹은 퀵 정렬에 기반하고 시간 복잡도 $O\left(N\log N\right)$을 보장한다고 하네요.  
이러한 `sorted()` 함수는 리스트나 집합, 딕셔너리 자료형을 입력받아 정렬된 결과를 출력합니다. 단, 반환하는 자료형은 항상 리스트 자료형입니다.  
```Python
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

result = sorted(array)
print(result)
```  
리스트 변수가 하나 있을 때는 내부 원소를 바로 정렬할 수도 있습니다. 리스트 객체의 `sort()` 메서드를 이용하는 방법입니다. 별도의 정렬된 리스트를 반환하지 않고 내부 원소를 바로 정렬시킬 때 사용합니다.  
```Python
array = [7, 5, 9, 0, 3, 1, 6, 2, 4, 8]

array.sort()
print(result)
```  
`sorted()`나 `sort()`를 사용할 때에는 `key` 매개변수를 입력으로 받을 수 있습니다. `key`에는 특정한 함수가 들어가며, 정렬의 기준이 됩니다. 혹은 람다(lambda) 함수를 사용할 수도 있습니다.  
```Python
array = [('바나나', 2), ('사과', 5), ('당근', 3)]

result = sorted(array, key=lambda x:x[1])
print(result)
```  
### 정렬 라이브러리의 시간 복잡도
정렬 라이브러리는 최악의 경우에도 시간 복잡도 $O\left(N\log N\right)$을 보장합니다. 이미 잘 작성된 함수이기 때문에 우리가 직접 퀵 정렬을 구현할 때보다 효과적입니다. 문제에서 별도로 요구가 없다면, 단순히 정렬해야 하는 상황에서는 기본 정렬 라이브러리를 사용하면 됩니다. 대신, 데이터의 범위가 한정되어 있으며 더 빠르게 동작해야 할 때는 계수 정렬을 사용합시다.  
일반적으로 코딩 테스트에서는 정렬 알고리즘이 사용되는 경우를 3가지로 나눌 수 있습니다.  
1. 정렬 라이브러리로 풀 수 있는 문제: 단순히 정렬 기법을 알고 있는지 물어보는 문제. 정렬 라이브러리 사용 방법만 알고 있으면 쉽게 풀 수 있습니다.
2. 정렬 알고리즘의 원리를 물어보는 문제: 선택 정렬, 삽입 정렬, 퀵 정렬의 원리를 알아야만 풀 수 있습니다. 
3. 더 빠른 정렬이 필요한 문제: 계수 정렬 등의 다른 정렬 알고리즘을 이용하거나 문제에서 기존에 알려진 알고리즘의 구조적인 개선을 요구하는 문제입니다.