# 배열 개념
배열은 인덱스와 값을 일대일 대응해 관리하는 자료구조입니다. 데이터를 저장할 수 있는 모든 공간이 인덱스와 일대일 대응하므로 어떤 위치에 있는 데이터든 한 번에 접근할 수 있습니다.  
> 어디에 있는지만 알면 빠르게 탐색할 수 있으며, 이러한 접근 방식을 **임의 접근**(random access)라고 합니다.  

## 배열 선언
파이썬에서 배열은 리스트 자료형을 이용해 선언하는 것이 일반적입니다. 사실 파이썬의 리스트는 엄밀한 의미의 배열과는 개념이 다르고, 실제 배열을 지정하는 것은 서드파티 라이브러리(넘파이 등)를 이용해야만 가능합니다. 하지만 배열의 웬만한 기능은 파이썬의 리스트로도 구현할 수 있기 때문에 여기서는 리스트를 사용하겠습니다.
### 일반적인 방법
```Python
# 두 방식 모두 동일한 배열을 선언합니다.
arr = [0, 0, 0, 0, 0, 0]
arr = [0] * 6
```  
### 리스트 생성자를 사용할 경우
```Python
arr = list(range(6))
```  
### 리스트 컴프리헨션
```Python
arr = [0 for _ in range(6)]
```  

## 배열과 차원
**배열은 차원과는 무관하게 메모리에 연속 할당됩니다.** 풀어서 설명하자면, 컴퓨터 메모리의 구조가 1차원이기 때문에 실제로는 2차원이나 3차원 이상의 배열도 1차원 공간에 저장된다는 뜻입니다.
### 1차원 배열
배열의 각 데이터가 메모리의 낮은 주소에서 높은 주소 방향으로 연이어 할당됩니다. 위 예제에서 보인 세 가지 예시가 모두 1차원 배열에 해당됩니다.
### 2차원 배열
```Python
arr = [[1, 2, 3, 4], [5, 6, 7, 8], [9, 10, 11, 12]]
arr = [[i] * 4 for i in range(3)] # [[0, 0, 0, 0], [1, 1, 1, 1], [2, 2, 2, 2]]
```  
2차원 배열 데이터에 접근하는 방법도 1차원 배열과 비슷합니다. 단, 행과 열을 명시해 `[]` 연산자를 2개 연이어 사용해야 합니다. 또한 사람이 이해하기로는 마치 표나 행렬처럼 행과 열로 표현되지만, 실제 컴퓨터 메모리에 저장될 때는 0행을 먼저 1차원 공간에 저장하고 곧바로 이어서 1행의 데이터를 저장합니다.

# 배열의 효율성
## 배열의 시간 복잡도
* 데이터 접근 연산: 배열은 *임의 접근*을 통해 배열의 모든 위치에 있는 데이터에 단 한 번에 접근할 수 있습니다. 따라서 배열에 있는 하나의 요소에 접근할 때의 시간 복잡도는 $O\left(1\right)$입니다.  
* 데이터 추가: 배열은 데이터를 어디에 저장하느냐에 따라 시간 복잡도가 달라집니다. 자세한 내용은 후술하겠지만, 배열은 특정한 경우에 데이터 추가나 삭제에 드는 비용이 제각기 다릅니다. 따라서 배열에 데이터를 저장할 때는 항상 이런 비용을 생각해야 합니다.
### 맨 뒤에 삽입할 때
마지막 인덱스에 곧장 임의 접근을 할 수 있습니다. 또한 데이터를 삽입해도 다른 데이터 위치에는 영향이 없습니다. 따라서 시간 복잡도는 $O\left(1\right)$입니다.
### 맨 앞에 삽입할 때
기존 데이터들을 뒤로 한 칸씩 밀어야 합니다. 따라서, 데이터 개수를 $N$이라고 하면 시간 복잡도는 $O\left(N\right)$이 됩니다.
### 중간에 삽입할 때
현재 삽입한 데이터 뒤에 있는 데이터 개수만큼 미는 연산을 해야 합니다. 따라서 최악의 경우의 시간 복잡도는 $O\left(N\right)$이 됩니다.

## 배열 자료구조를 선택할 때 고려할 점
데이터에 자주 접근하거나 읽어야 할 경우 배열은 성능이 좋습니다. 하지만 배열의 모든 원소를 저장하기 위해 메모리 공간을 충분히 확보해야만 하므로, 배열을 적절하지 못하게 선언하면 메모리 낭비가 발생할 수 있습니다. 따라서 아래와 같이 크게 두 가지 사항을 고려해 배열 자료구조를 사용할지를 결정합니다.  
1. 할당할 수 있는 메모리 크기는 충분한가?<br/>운영체제마다 배열을 할당할 수 있는 메모리의 한계치가 다릅니다. 하지만 보통 *정수형 1차원 배열*에 1000만 개, 2차원 배열은 $3000\times 3000$을 상한치로 봅니다.
2. 중간에 데이터 삽입을 자주 하는가?<br/>배열은 선형 자료구조이기 때문에 중간이나 맨 앞에 데이터를 자주 삽입하면 시간 복잡도가 높아집니다. 시간 초과에 걸릴 수도 있겠죠.

> 엄밀한 의미의 배열 자료구조는 선언하기 전에 배열의 크기와 그 안에 들어갈 요소들의 공통 자료형을 미리 지정해야 합니다. 하지만 파이썬의 리스트는 선언한 이후에도 새 자료를 추가하거나 삭제하는 과정이 자유롭습니다. 따라서 당장은 배열의 크기는 신경쓰지 않아도 됩니다.  

# 자주 쓰는 리스트의 메서드 모음집
## 데이터 추가
### `append()`
맨 끝에 데이터를 추가합니다.
```Python
my_list = [1, 2, 3]
my_list.append(4) # [1, 2, 3, 4]
```  
### `+` 연산자
맨 끝에 *다른 리스트*의 데이터를 추가합니다. 원소를 하나만 추가하고 싶을 때도 `[4]`와 같이 리스트로 정의한 후에 사용해야 합니다!  
```Python
my_list = [1, 2, 3]
my_list = my_list + [4, 5] # [1, 2, 3, 4, 5]
```  
### `insert()`
특정 위치에 데이터를 삽입합니다. 이 메서드는 데이터를 삽입할 위치의 인덱스와 삽입할 데이터 순서대로 인수를 입력받습니다.  
```Python
my_list = [1, 2, 3, 4, 5]
my_list.insert(2, 10) # [1, 2, 10, 3, 4, 5]
```  

## 데이터 삭제
### `pop()`
특정 위치의 데이터를 삭제하고, 삭제한 데이터의 값을 반환합니다. 반환한 값은 별도의 변수로 지정해 저장할 수 있고, 그렇지 않고 단독으로 사용하면 데이터 삭제만 수행합니다.  
```Python
my_list = [1, 2, 3, 4, 5]
popped_element = my_list.pop(3)
print(my_list, popped_element) # [1, 2, 3, 5], 4
```  
### `remove()`
특정 위치가 아니라 데이터 자체의 값을 찾아서 삭제하고 싶을 때 사용합니다. 인수로 받은 값이 처음 등장하는 위치의 데이터를 삭제하기 때문에, 해당 값이 원본 배열에서 중복으로 존재할 경우에는 여러 번 사용해야 합니다.  
```Python
my_list = [1, 2, 3, 4, 5]
my_list.remove(2) # [1, 3, 4, 5]
```  
## 리스트 컴프리헨션
List comprehension. 반복문, 조건문을 이용해 복잡한 리스트를 생성하는 등 쓰임새가 많은 기법입니다. 기존에 존재하는 리스트의 원소를 반복문에 이용하는 것도 가능합니다.
### 리스트에 제곱 연산 적용 예시
```Python
numbers = [1, 2, 3, 4, 5]
squares = [n ** 2 for n in numbers] ## [1, 4, 9, 16, 25]
```  

## 그 외의 유용한 메서드
* `len()`: 리스트의 전체 데이터 개수 반환
* `index()`: 해당 데이터가 *처음* 등장한 인덱스를 반환. 없으면 -1을 반환.
* `sort()`: 사용자가 정한 기준에 따라 리스트의 요소들을 정렬. 기본값은 오름차순 정렬. `reverse=True`로 인수를 지정할 경우 내림차순 정렬.
* `count()`: 특정 데이터의 개수를 반환.  

```Python
fruits = ["apple", "banana", "cherry", "apple", "orange", "banana", "kiwi"]
len(fruits) # 7
fruits.index("banana") # 1
fruits.sort() # ["apple", "apple", "banana", "banana", "cherry", "kiwi", "orange"]
fruits.count("apple") # 2
```